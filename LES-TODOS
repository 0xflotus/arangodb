done
----
- create new branch
- factor out transactions from LogfileManager
- concept "collection locks"
    - 3 states: READ / WRITE / EXCLUSIVE for locks
- index implementations => moved & renamed to StorageEngine
- move engine files into MMFiles directory
- split IndexElement
- rename *IndexElement to MMFiles*
- move fulltext & geoindex & skiplist helper code into MMFiles
- rename "RocksDBIndex" to "PersistentIndex"
- Delete OperationCursor->getMore. Replace by getMoreTokens
- remove ReadCache

in progress
-----------
- Index API
  - Rename OperationCursor->getMoreMptr => getMoreTokens, "returns" std::vector<TOKEN>&

to do
-----
- move engine-specific parts of transaction.cpp into engine
- transaction API
- check for illegal includes
- fix includes during API conversion
- DML API
- DDL API
- index API
- add new serialization RW lock to LogicalCollection. all DML ops must acquire it in read mode, the explicit lock command must acquire it in write mode.
- StorageEngineAPI readDocument requires 2 functions:
  - void readDocument(TOKEN id, VPackBuilder& result)  => Collects the document and inserts it asis into result. Does NOT clear result.
  - void readDocument(TOKEN id, std::vector<std::string> const& attributePath, VPackBuilder& result) => Collects the document and writes only the value at the given attributePath (e.g. `a.b.c`) into result. Does NOT clear result.

- Indexes always return std::vector<TOKEN>
- AqlValue needs a (lazy evaluated) type TOKEN that handles collection ID and TOKEN inplace.
  - slice() => looksup the value in the Database

